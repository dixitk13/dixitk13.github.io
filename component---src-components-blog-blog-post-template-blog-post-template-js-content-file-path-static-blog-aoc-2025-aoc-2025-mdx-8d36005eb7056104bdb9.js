"use strict";(self.webpackChunkdixitk13_github_io=self.webpackChunkdixitk13_github_io||[]).push([[970],{1193:function(e,t,n){n.r(t),n.d(t,{default:function(){return p}});var a=n(8453),r=n(6540);function o(e){const t=Object.assign({p:"p",h2:"h2",a:"a",span:"span",strong:"strong",ul:"ul",li:"li"},(0,a.RP)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.p,null,"This has been the first year-end I‚Äôve been able to try out AOC (Advent of Code) during the December holidays. And it‚Äôs been a fabulous journey!"),"\n",r.createElement(t.p,null,"I was always aware of AOC, but never took the time to attempt it. With December being a high travel month, it was easy to let it slip. But alas, these are just excuses."),"\n",r.createElement(t.p,null,"This year, I‚Äôve had company and was motivated by my teammate, who helped me keep pace. So I thank him dearly. I‚Äôm pretty sure my SO isn‚Äôt that thankful üòÖ because of the amount of time I‚Äôve spent solving AOC."),"\n",r.createElement(t.p,null,"It would be futile to attempt to explain the questions, so I‚Äôve left a link to them instead."),"\n",r.createElement(t.p,null,"So what did I really learn? Lots of string parsing, data structures, because of the way inputs are given, along with algorithms - of course! I wrote this article to share the specific technical hurdles, my transition from intuition to formal algorithms, and the lessons learnt with respect to software engineering."),"\n",r.createElement(t.h2,{id:"Day-1Ô∏è-Secret-entrance",style:{position:"relative"}},r.createElement(t.a,{href:"#Day-1%EF%B8%8F-Secret-entrance","aria-label":"Day 1Ô∏è Secret entrance permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Day 1Ô∏è‚É£ ",r.createElement(t.a,{href:"https://adventofcode.com/2025/day/1",target:"_blank",rel:"nofollow noopener noreferrer external"},"Secret entrance")),"\n",r.createElement(t.p,null,"‚ú®Circular queue"),"\n",r.createElement(t.p,null,"The secret entrance began as a circular queue problem where one would count the number of times you reach the starting position given inputs to rotate left or right on a given ‚Äúdial‚Äù or circular queue."),"\n",r.createElement(t.p,null,"Part 1 is straightforward; it asks you to count how many times you land on the starting point while moving clockwise or counterclockwise. I started off with a simple loop, keeping a counter and applying a modulo to every operation to figure out if we land on the defined starting point."),"\n",r.createElement(t.p,null,"As you move to part 2, the problem picks up its pace and forces you to think out of the modulo operation, and advances to counting the number of times you‚Äôd ‚Äútouch‚Äù the starting point of a circular queue when moving around. Here, I took some back and forth to realize a bit of math would be useful and relied on maintaining previous and next plus division by 100 to account for touching the starting point."),"\n",r.createElement(t.h2,{id:"Day-2Ô∏èGift-shop",style:{position:"relative"}},r.createElement(t.a,{href:"#Day-2%EF%B8%8FGift-shop","aria-label":"Day 2Ô∏èGift shop permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Day 2Ô∏è‚É£¬†",r.createElement(t.a,{href:"https://adventofcode.com/2025/day/2",target:"_blank",rel:"nofollow noopener noreferrer external"},"Gift shop")),"\n",r.createElement(t.p,null,"‚ú®Two-pointers & pattern-match"),"\n",r.createElement(t.p,null,"The gift shop starts as a pattern-matching problem where one needs to find ‚ÄúInvalid ID‚Äù between ranges of numbers, and I tried to attempt that with two pointers for part 1."),"\n",r.createElement(t.p,null,"As you move to part 2, the invalid algorithm changes, and I had to resort to using brute force in finding a repeating pattern across the given number. I sliced the string in an incremental manner and validated towards the ending if the number of times a slice of string matched the ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">length-of-string / slice-length</code>'}})," ."),"\n",r.createElement(t.p,null,"I tried a bunch of other algorithms to attempt this, but resorted to brute force towards the end. I‚Äôm sure there‚Äôs a more optimized way to do the gift shop, but so be it."),"\n",r.createElement(t.h2,{id:"Day-3Ô∏èLobby",style:{position:"relative"}},r.createElement(t.a,{href:"#Day-3%EF%B8%8FLobby","aria-label":"Day 3Ô∏èLobby permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Day 3Ô∏è‚É£¬†",r.createElement(t.a,{href:"https://adventofcode.com/2025/day/3",target:"_blank",rel:"nofollow noopener noreferrer external"},"Lobby")),"\n",r.createElement(t.p,null,"‚ú®Greedy algorithm & monotonic stack"),"\n",r.createElement(t.p,null,"Lobby focusses on giving a numeric input and finding the maximum number that can be formed using the digits in the input. So if the given input is ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">81111111111119</code>'}})," the part 1 answer would be ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">89</code>'}}),", and the part two answer would be ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">8&lt;10-number-of-1s>9</code>'}})," ‚áí ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">811111111119</code>'}}),"."),"\n",r.createElement(t.p,null,"Part 1 began with finding two digits in a number for it to become the maximum number possible while maintaining relative positions. I greedily selected the maximum number from the list of numbers and then proceeded to find a second number from the previously maximum found number index, allowing to find the maximum two-digit number. This was again a brute force attempt."),"\n",r.createElement(t.p,null,"As you move to part 2, this algorithm becomes futile because now you‚Äôre asked to find the maximum number using 12 such numbers, whilst maintaining relative positions. I had to skip this one on the specific day because the stack did not strike me at all! When re-attempting monotonic stack helped keep numbers in increasing order while maintaining relative positions to find the maximum formed number."),"\n",r.createElement(t.h2,{id:"Day-4Ô∏èPrinting-department",style:{position:"relative"}},r.createElement(t.a,{href:"#Day-4%EF%B8%8FPrinting-department","aria-label":"Day 4Ô∏èPrinting department permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Day 4Ô∏è‚É£¬†",r.createElement(t.a,{href:"https://adventofcode.com/2025/day/4",target:"_blank",rel:"nofollow noopener noreferrer external"},"Printing department")),"\n",r.createElement(t.p,null,"‚ú®Grid traversal. Breadth-first search."),"\n",r.createElement(t.p,null,"The printing department focused on a grid-based input and needed one to apply logical calculations based on the cells around a grid index."),"\n",r.createElement(t.p,null,"Part 1 focuses on finding cells that have fewer than 4 neighbor ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">"@"</code>'}})," (roll) symbols in the given input grid. This is a straight-up grid traversal problem."),"\n",r.createElement(t.p,null,"Part 2 focuses on continuously removing the number of rolls based on grid density until the grid is stable - I attempted it via a normal loop, re-computed the grid, and did the entire grid scan again to remove additional rolls."),"\n",r.createElement(t.p,null,"I‚Äôd say this could be attempted in a BFS fashion for efficiency by reducing the ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">O(N^2)</code>'}})," incurred via rescans. The BFS could enqueue all the grid indexes with less than 4 rolls, and when we dequeue, we could enqueue if a grid index had dropped below 4 count. The result would be the number of elements we dequeued. The complexity would drop to. ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">O(E + V)</code>'}})," where ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">V</code>'}})," being the vertices enqueued for grid indexes with less than 4 rolls and ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">E</code>'}})," would be the edges processed. The BFS again did not strike me at that very time because the brute-force was pretty easy; I wish the input size had stopped my brute-force."),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Bonus:")),"\n",r.createElement(t.p,null,"The problem focused on grid traversal, and I learnt two new terms here viz. Moore neighborhood and Von Neumann neighborhood."),"\n",r.createElement(t.p,null,"Usually, in grids, one looks at the N, S, E, and W directions are shown below. This is known as the ",r.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Von_Neumann_neighborhood",target:"_blank",rel:"nofollow noopener noreferrer external"},"Von Neumann neighborhood")," (4-neighborhood). (The hyphens (-) are not counted)"),"\n",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">[ - , N, - ]\n[ W,  P, E ]\n[ - , S, - ]</code></pre></div>'}}),"\n",r.createElement(t.p,null,"Whereas the ",r.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Moore_neighborhood",target:"_blank",rel:"nofollow noopener noreferrer external"},"Moore neighborhood")," consists of the 8 cells that surround the centerpiece, viz. NW, N, NE, W, E, SW, S, SE."),"\n",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">[ NW, N, NE]\n[ W,  P,  E]\n[ SW, S, SE]</code></pre></div>'}}),"\n",r.createElement(t.h2,{id:"Day-5Ô∏èCafeteria",style:{position:"relative"}},r.createElement(t.a,{href:"#Day-5%EF%B8%8FCafeteria","aria-label":"Day 5Ô∏èCafeteria permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Day 5Ô∏è‚É£¬†",r.createElement(t.a,{href:"https://adventofcode.com/2025/day/5",target:"_blank",rel:"nofollow noopener noreferrer external"},"Cafeteria")),"\n",r.createElement(t.p,null,"‚ú®¬†Merge Intervals"),"\n",r.createElement(t.p,null,"Cafeteria begins with a list of ‚Äúfresh ingredients‚Äù, ranges, and product IDs that need to be evaluated as being fresh."),"\n",r.createElement(t.p,null,"Day 1 was easy: check if a number is between any of the possible ranges.\nDay 2 asks to determine the number of fresh ingredients from the given ranges. I tried building on top of the existing code to calculate, but there were more use-cases of overlapping intervals. Like a lazy developer, I tried applying a set to maintain uniqueness, but it failed miserably with a memory out of bounds error, which was interesting to say the least. Then I tried a fancy bloom filter to see if I could uniquely identify the fresh ingredients, to avoid processing already processed elements when looping through overlapping intervals, and that didn‚Äôt work either."),"\n",r.createElement(t.p,null,"With some hints about ‚Äúpre-preprocessing‚Äù from a friend, it struck me - OMG - this is merge intervals! Merge intervals and then calculate the difference between two intervals and add one to offset! A simple merge is shown below to understand the use-case, and of-course the ranges are sorted."),"\n",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">const processRanges = (ranges: number[][]): number[][] => {\n  if (ranges.length &lt;= 1) return ranges;\n\n  const result = [];\n  let prev = ranges[0];\n\n  for (let i = 1; i &lt; ranges.length; i++) {\n    let curr = ranges[i];\n    if (curr[0] &lt;= prev[1]) {\n      prev = [prev[0], Math.max(prev[1], curr[1])];\n    } else {\n      result.push(prev);\n      prev = curr;\n    }\n  }\n  if (prev) result.push(prev);\n\n  return result;\n};</code></pre></div>'}}),"\n",r.createElement(t.h2,{id:"Day-6Ô∏èTrash-Compactor",style:{position:"relative"}},r.createElement(t.a,{href:"#Day-6%EF%B8%8FTrash-Compactor","aria-label":"Day 6Ô∏èTrash Compactor permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Day 6Ô∏è‚É£¬†",r.createElement(t.a,{href:"https://adventofcode.com/2025/day/6",target:"_blank",rel:"nofollow noopener noreferrer external"},"Trash Compactor")),"\n",r.createElement(t.p,null,"‚ú® Matrix processing"),"\n",r.createElement(t.p,null,"Trash compactor was about a certain math variation that involved treating the input like a matrix and performing mathematical operations on it in a columnar fashion."),"\n",r.createElement(t.p,null,"For part 1, the math focussed on using the last row as a mathematical operators to apply on all of the rows above the operator. Which was pretty straightforward. Splitting the array on space would give out the matrix values, and one could operate as per the logic requested."),"\n",r.createElement(t.p,null,"For part 2, the question twists itself, which makes you consider each cell index in the input as a singular column, along with treating the topmost row as the Most Significant Bit (MSB) and the lowest bit as the Least Significant Bit (LSB). This significantly changed the way I designed the input parsing and needed me to design an algorithm that would iterate the input from top-right to bottom and move left iteratively - alongside applying the MSB logic. It reminded me of school math, but not really! üòÑ"),"\n",r.createElement(t.h2,{id:"Day-7Ô∏èLaboratories",style:{position:"relative"}},r.createElement(t.a,{href:"#Day-7%EF%B8%8FLaboratories","aria-label":"Day 7Ô∏èLaboratories permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Day 7Ô∏è‚É£¬†",r.createElement(t.a,{href:"https://adventofcode.com/2025/day/7",target:"_blank",rel:"nofollow noopener noreferrer external"},"Laboratories")),"\n",r.createElement(t.p,null,"‚ú®Grid traversal and DFS"),"\n",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">Tachyon: A tachyon or tachyonic particle is a hypothetical particle that always\ntravels faster than light</code></pre></div>'}}),"\n",r.createElement(t.p,null,"Laboratories began with an input grid consisting of a start of tachyon beam light, and then the light splits into two at grid indexes where the input string would be ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">^</code>'}}),". A beautiful input diagram is shown in the question itself."),"\n",r.createElement(t.p,null,"Part 1 began with an input location and splitters (",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">^</code>'}})," ) and requests to find how many times the beam would split. I tried solving this by updating the grid with the beam positions ( ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">|</code>'}})," ) after a split and moving top-to-bottom on the grid."),"\n",r.createElement(t.p,null,"Part 2 twists this question and requests to figure out how many unique paths would that tachyon beam light would take. This was a straight-up DFS (Depth First Search) question, but since my prior solution worked by updating the grid, I basically did a backtracking solution which updates the grid by marking the beam positions and cleaning them up before trying another path, and calculates all paths that make it to the end of the grid. After a lot of back-and-forth, I realized this is better solved with a DFS. I honestly wasn‚Äôt able to write this DFS would, and I was pretty bumped about it, but looking back, that DFS quote, unquote, ‚Äúwas straightforward to come up with‚Äù."),"\n",r.createElement(t.h2,{id:"Day-8Ô∏èPlayground",style:{position:"relative"}},r.createElement(t.a,{href:"#Day-8%EF%B8%8FPlayground","aria-label":"Day 8Ô∏èPlayground permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Day 8Ô∏è‚É£¬†",r.createElement(t.a,{href:"https://adventofcode.com/2025/day/8",target:"_blank",rel:"nofollow noopener noreferrer external"},"Playground")),"\n",r.createElement(t.p,null,"‚ú®Union-find (or via DFS)"),"\n",r.createElement(t.p,null,"Playground begins with a list of input co-ordinates for ‚Äújunction boxes‚Äù in 3D space."),"\n",r.createElement(t.p,null,"Part 1 requests you to find out the multiplication of the top 3 ‚Äúislands‚Äù you can form in the 3D space. This is a classical leetcode style problem, and you can either use DFS or Union Find(UF)."),"\n",r.createElement(t.p,null,"Part 2 takes it one step forward and requests you to find the last two remaining ‚Äújunction boxes‚Äù (or points) whilst performing the union. Maintaining the size of UF - one can determine this easily. It takes a bit of back & forth sometimes to determine who becomes a parent while joining a set."),"\n",r.createElement(t.p,null,"Pro-tip for distance calculation is just using the squared values instead of trying to really create a Euclidean distance by taking ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Math.sqrt</code>'}}),"."),"\n",r.createElement(t.p,null,"Bonus: Union-Find has been my favorite algorithm for a few years now. The ‚Äúweek‚Äù I discovered it, I basically have formulated a pattern around how you can apply this in problems, and its a fantastic algorithm! A very brief overview of how simple the algorithm can be is shown below:"),"\n",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// declare union-find parent array, initialize with self as parent\nlet uf = Array.from({ length: points.length }).map((_, idx) => idx);\n\n// a find function which recursively goes up the parent chain\nconst find = (x: number, uf: number[]): number => {\n  if (uf[x] !== x) {\n    uf[x] = find(uf[x], uf);\n  }\n  return uf[x];\n};\n\n// during your algorithm, find parent\'s for the two items\n// you\'d like to join in a set\nlet pi = find(i, uf);\nlet pj = find(j, uf);\n\n// union them\nuf[pi] = pj;</code></pre></div>'}}),"\n",r.createElement(t.p,null,"If you‚Äôve not tried or heard of UF before, I suggest watching a few videos and trying this out with a paper & pen."),"\n",r.createElement(t.h2,{id:"Day-9Ô∏èMovie-theater",style:{position:"relative"}},r.createElement(t.a,{href:"#Day-9%EF%B8%8FMovie-theater","aria-label":"Day 9Ô∏èMovie theater permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Day 9Ô∏è‚É£¬†",r.createElement(t.a,{href:"https://adventofcode.com/2025/day/9",target:"_blank",rel:"nofollow noopener noreferrer external"},"Movie theater")),"\n",r.createElement(t.p,null,"‚ú®Brute-force"),"\n",r.createElement(t.p,null,"Movie theater input consisted of ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">#</code>'}})," tiles given as ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">(x,y)</code>'}})," co-ordinates and requests to find the largest rectangle for part 1. I tried to attempt this via brute force, which solved the use-case but did not finish part 2."),"\n",r.createElement(t.h2,{id:"Day-1Ô∏è0Ô∏è-Factory",style:{position:"relative"}},r.createElement(t.a,{href:"#Day-1%EF%B8%8F0%EF%B8%8F-Factory","aria-label":"Day 1Ô∏è0Ô∏è Factory permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Day 1Ô∏è‚É£0Ô∏è‚É£ ",r.createElement(t.a,{href:"https://adventofcode.com/2025/day/10",target:"_blank",rel:"nofollow noopener noreferrer external"},"Factory")),"\n",r.createElement(t.p,null,"‚ú®Power-set. Math-trick ‚Üí bifurcate"),"\n",r.createElement(t.p,null,"The factory began with indicators, buttons, and joltage. I‚Äôm not even going to try explaining this input, but this is an interesting question."),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"Indicators are a list of indices we need in the¬†",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ON</code>'}}),"¬†state."),"\n",r.createElement(t.li,null,"Buttons are a tuple of indexes that can turn Indicators¬†",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ON</code>'}}),"¬†or¬†",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">OFF</code>'}}),", but all the indexes listed in the tuple get applied together to turn the indicators¬†",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ON</code>'}}),"¬†or¬†",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">OFF</code>'}}),"."),"\n",r.createElement(t.li,null,"Joltage is the number of a button index is needed to be pressed for ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ON</code>'}})," ."),"\n"),"\n",r.createElement(t.p,null,"Part 1 focuses on finding a set of buttons that can create the list of Indicators. The buttons can turn the indicator ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ON</code>'}})," and ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">OFF</code>'}}),", so you‚Äôd need to formulate the logic such that you end with all the indicators in the ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ON</code>'}})," state. I created a variety of helper functions that would simulate whether the list of buttons would give a valid end state. Along with parsing logic and a backtracking subsets function. I did a brute force of finding a power set given the list of tuples. The complexity of a power-set calculation is ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">O(2^N)</code>'}}),", after which I applied a filtering logic via a helper function to find if that specific set of buttons would end in a valid state."),"\n",r.createElement(t.p,null,"Part 2, and by far I think this is the hardest question I‚Äôve seen in AOC, needed to form the joltage values via the buttons. I wasn‚Äôt able to solve this question by myself and needed help, but here‚Äôs an excellent explanation from ",r.createElement(t.a,{href:"https://www.reddit.com/r/adventofcode/comments/1pk87hl/2025_day_10_part_2_bifurcate_your_way_to_victory/",target:"_blank",rel:"nofollow noopener noreferrer external"},"reddit")," which will make more sense than me trying to explain."),"\n",r.createElement(t.p,null,"The author breaks part 2 down to part 1 and applies a recursive function & math trick to find the number of sets, which help find the answer."),"\n",r.createElement(t.h2,{id:"Day-1Ô∏è1Ô∏è-Reactor",style:{position:"relative"}},r.createElement(t.a,{href:"#Day-1%EF%B8%8F1%EF%B8%8F-Reactor","aria-label":"Day 1Ô∏è1Ô∏è Reactor permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Day 1Ô∏è‚É£1Ô∏è‚É£ ",r.createElement(t.a,{href:"https://adventofcode.com/2025/day/11",target:"_blank",rel:"nofollow noopener noreferrer external"},"Reactor")),"\n",r.createElement(t.p,null,"‚ú®Adjacency list, DFS and math tricks"),"\n",r.createElement(t.p,null,"Reactor input consisted of adjaceny list as input and variable start or end points."),"\n",r.createElement(t.p,null,"Part 1 problem was a straight up DFS, which requested to find the number of paths between a given start and end input points."),"\n",r.createElement(t.p,null,"Part 2 was also a DFS-ish question which requested to count the number of paths between given start and end points, but needed to visit two intermediary points. I tried amending my prior DFS for part 1 to include the two intermediary points and count the paths. It worked for the sample input, but did not finish running for the larger input, even after applying caching. After a bit of searching on the web, the solution seems to indicate math tricks and explained why regular DFS would not finish in time - basically the number of paths explode which makes the DFS take longer."),"\n",r.createElement(t.p,null,"The math trick goes like this, and it blows my mind ü§Ø:"),"\n",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">// Starting point being "A", ending being "Z"\n// and your intermediary points being P and Q\n\n\t// a function which returns the number of paths between start end\n  function dfs (start, end) { ... }\n\n  let series1 = dfs("A", "P") * dfs("P", "Q") * dfs("Q", "Z")\n  let series2 = dfs("A", "Q") * dfs("Q", "P") * dfs("P", "Z")\n  let result = series1 + series2;</code></pre></div>'}}),"\n",r.createElement(t.p,null,"What it tries to do is calculate the dfs path count from ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">A</code>'}})," to ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">P</code>'}})," multiply them with path counts from ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">P</code>'}})," to ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Q</code>'}})," and further multiple them with ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Q</code>'}})," to ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Z</code>'}}),". This would give out all the paths possible from ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">A</code>'}})," to ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Z</code>'}})," via ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">P</code>'}})," and ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Q</code>'}}),". Trying this out with a smaller example is extremely helpful!"),"\n",r.createElement(t.h2,{id:"Day-1Ô∏è2Ô∏è-Christmas-tree-farm",style:{position:"relative"}},r.createElement(t.a,{href:"#Day-1%EF%B8%8F2%EF%B8%8F-Christmas-tree-farm","aria-label":"Day 1Ô∏è2Ô∏è Christmas tree farm permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Day 1Ô∏è‚É£2Ô∏è‚É£ ",r.createElement(t.a,{href:"https://adventofcode.com/2025/day/12",target:"_blank",rel:"nofollow noopener noreferrer external"},"Christmas tree farm")),"\n",r.createElement(t.p,null,"‚ú®Brute-force"),"\n",r.createElement(t.p,null,"Christmas tree farm input consists of irregularly shaped presents denoted via ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">#</code>'}})," and regions, denoted via length (",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">l</code>'}}),") and width (",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">w</code>'}}),") of the region, followed by the count of presents required in that region. The task is to determine if a region can accommodate all the present listed items."),"\n",r.createElement(t.p,null,"Honestly, for part 1, I pondered for an hour and quickly gave up because I was unsure how to design the packing algorithm. Turns out people solved this with a brute force without implementing any shape fitting logic and subtracting area with ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">l * w</code>'}}),"."),"\n",r.createElement(t.p,null,"And since I couldn‚Äôt finish all the above part 2 questions, I couldn‚Äôt attempt the Christmas tree farm part 2."),"\n",r.createElement(t.h2,{id:"Closing-thoughts",style:{position:"relative"}},r.createElement(t.a,{href:"#Closing-thoughts","aria-label":"Closing thoughts permalink",className:"auto-link-header-class before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" height="20" version="1.1" viewBox="0 0 16 16" width="20"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"‚≠ê¬†Closing thoughts"),"\n",r.createElement(t.p,null,"Overall, I felt that applying algorithmic problem-solving skills to unknown questions makes us all better engineers."))}var l=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.RP)(),e.components);return t?r.createElement(t,e,r.createElement(o,e)):o(e)},i=n(7581),s=n(7091),c=n(2003),h=n(5443),d=n(5147),u=n(5048);function m(e){let{data:t,children:n,pageContext:o}=e;if(!o)return null;const{frontmatter:l,excerpt:i,timeToReadInWords:h}=null!=o?o:{},{title:d,date:m}=null!=l?l:{};return r.createElement(s.Cc,null,r.createElement(u.T,{title:d,description:i||"nothin",article:!0}),r.createElement(s.IF,null,r.createElement(g,null,r.createElement(f,null,d),r.createElement("p",null,"Last updated: ",m," ‚Ä¢"," ",h&&r.createElement("span",null,h))),r.createElement(a.xA,{components:c.ol},n)))}function p(e){return r.createElement(m,e,r.createElement(l,e))}const g=i.default.div.attrs({tabIndex:0}).withConfig({displayName:"BlogPostTemplate__BlogHeader",componentId:"sc-aqkyp8-0"})(["padding:"," 0 0 0;width:100%;text-align:center;p{opacity:0.8;font-size:",';&:after{content:"";margin:'," auto;display:block;width:200px;height:2px;border-radius:50%;background-color:",";opacity:0.4;}}"],(0,h.di)(1),(0,h.di)(.75),(0,h.di)(1),d.T8),f=i.default.h1.withConfig({displayName:"BlogPostTemplate__BlogTitle",componentId:"sc-aqkyp8-1"})(["color:",';font-weight:900;font-size:40px;font-family:"Futura PT",-apple-system,sans-serif;'],d.T8)},8453:function(e,t,n){n.d(t,{RP:function(){return o},xA:function(){return i}});var a=n(6540);const r=a.createContext({});function o(e){const t=a.useContext(r);return a.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const l={};function i({components:e,children:t,disableParentContext:n}){let i;return i=n?"function"==typeof e?e({}):e||l:o(e),a.createElement(r.Provider,{value:i},t)}}}]);
//# sourceMappingURL=component---src-components-blog-blog-post-template-blog-post-template-js-content-file-path-static-blog-aoc-2025-aoc-2025-mdx-8d36005eb7056104bdb9.js.map